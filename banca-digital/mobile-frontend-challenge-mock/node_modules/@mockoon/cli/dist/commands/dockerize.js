"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@oclif/core");
const fs_1 = require("fs");
const mkdirp_1 = require("mkdirp");
const mustache_1 = require("mustache");
const path_1 = require("path");
const config_1 = require("../config");
const cli_messages_constants_1 = require("../constants/cli-messages.constants");
const command_constants_1 = require("../constants/command.constants");
const docker_constants_1 = require("../constants/docker.constants");
class Dockerize extends core_1.Command {
    async run() {
        const { flags: userFlags } = await this.parse(Dockerize);
        const resolvedDockerfilePath = (0, path_1.resolve)(userFlags.output);
        const dockerfilePath = (0, path_1.parse)(resolvedDockerfilePath);
        await (0, mkdirp_1.mkdirp)(dockerfilePath.dir);
        if (userFlags.data.length !== userFlags.port.length) {
            this.error(cli_messages_constants_1.CLIMessages.DOCKERIZE_PORT_DATA_MISMATCH);
        }
        try {
            const filePaths = [];
            let entrypoint = [
                'mockoon-cli',
                'start',
                '--disable-log-to-file',
                '--data'
            ];
            // copy or download the data files next to the generated Dockerfile
            for (const dataPath of userFlags.data) {
                const parsedDataPath = (0, path_1.parse)(dataPath);
                const fileName = parsedDataPath.ext !== '.json'
                    ? `${parsedDataPath.name}.json`
                    : parsedDataPath.base;
                if (dataPath.startsWith('http')) {
                    const resdata = await (await fetch(dataPath)).text();
                    await fs_1.promises.writeFile((0, path_1.resolve)(dockerfilePath.dir, fileName), resdata);
                }
                else {
                    await fs_1.promises.copyFile((0, path_1.resolve)(dataPath), (0, path_1.resolve)(dockerfilePath.dir, fileName));
                }
                filePaths.push(`./${fileName}`);
                entrypoint.push(`./${fileName}`);
            }
            entrypoint = [...entrypoint, '--port', ...userFlags.port.map(String)];
            if (userFlags['log-transaction']) {
                entrypoint.push('--log-transaction');
            }
            const dockerFile = (0, mustache_1.render)(docker_constants_1.DOCKER_TEMPLATE, {
                ports: userFlags.port.join(' '),
                filePaths,
                version: config_1.Config.version,
                entrypoint: JSON.stringify(entrypoint)
            });
            await fs_1.promises.writeFile(resolvedDockerfilePath, dockerFile);
            this.log(cli_messages_constants_1.CLIMessages.DOCKERIZE_SUCCESS, resolvedDockerfilePath);
            this.log(cli_messages_constants_1.CLIMessages.DOCKERIZE_BUILD_COMMAND, dockerfilePath.dir, 'mockoon-image', userFlags.port.map((port) => `-p ${port}:${port}`).join(' '), 'mockoon-image');
        }
        catch (error) {
            this.error(error.message);
        }
    }
}
Dockerize.description = 'Copy (or download) all the provided data files locally and create a Dockerfile to build a self-contained image of one or more mock API';
Dockerize.examples = [
    '$ mockoon-cli dockerize --data ~/data.json --output ./folder/Dockerfile',
    '$ mockoon-cli dockerize --data ~/data1.json ~/data2.json --output ./folder/Dockerfile',
    '$ mockoon-cli dockerize --data https://file-server/data.json --output ./folder/Dockerfile'
];
Dockerize.flags = {
    ...command_constants_1.commonFlags,
    port: core_1.Flags.integer({
        char: 'p',
        description: 'Ports to expose in the Docker container. It should match the number of environment data files you provide with the --data flag.',
        multiple: true,
        required: true
    }),
    output: core_1.Flags.string({
        char: 'o',
        description: 'Generated Dockerfile path and name (e.g. `./folder/Dockerfile`)',
        required: true
    })
};
exports.default = Dockerize;
//# sourceMappingURL=dockerize.js.map