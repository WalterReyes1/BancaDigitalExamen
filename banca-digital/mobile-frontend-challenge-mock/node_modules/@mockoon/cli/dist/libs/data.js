"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseDataFiles = void 0;
const commons_1 = require("@mockoon/commons");
const commons_server_1 = require("@mockoon/commons-server");
const cli_ux_1 = require("@oclif/core/lib/cli-ux");
const fs_1 = require("fs");
const cli_messages_constants_1 = require("../constants/cli-messages.constants");
/**
 * Check if an environment can be run by the CLI and
 * migrate it if needed.
 * Validate the environment schema (will automatically repair)
 *
 * @param environment
 */
const migrateAndValidateEnvironment = async (environment, forceRepair) => {
    // environment data are too old: lastMigration is not present
    if (environment.lastMigration === undefined && !forceRepair) {
        const promptResponse = await (0, cli_ux_1.confirm)(`${environment.name ? '"' + environment.name + '"' : 'This environment'} does not seem to be a valid Mockoon environment or is too old. Let Mockoon attempt to repair it? (y/n)`);
        if (!promptResponse) {
            throw new Error(cli_messages_constants_1.CLIMessages.DATA_TOO_OLD_ERROR);
        }
    }
    // environment data migrated with a more recent version (if installed CLI version does not include @mockoon/commons with required migrations)
    if (environment.lastMigration > commons_1.HighestMigrationId) {
        throw new Error(cli_messages_constants_1.CLIMessages.DATA_TOO_RECENT_ERROR);
    }
    try {
        // apply migrations
        commons_1.Migrations.forEach((migration) => {
            if (migration.id > environment.lastMigration) {
                migration.migrationFunction(environment);
            }
        });
    }
    catch (_error) {
        environment.lastMigration = commons_1.HighestMigrationId;
    }
    let validatedEnvironment = commons_1.EnvironmentSchema.validate(environment).value;
    if (!validatedEnvironment) {
        throw new Error(cli_messages_constants_1.CLIMessages.DATA_INVALID);
    }
    validatedEnvironment = (0, commons_1.repairRefs)(validatedEnvironment);
    return validatedEnvironment;
};
/**
 * Load and parse one or more JSON data file(s).
 *
 * @param filePaths
 */
const parseDataFiles = async (filePaths, userOptions = { ports: [], hostnames: [] }, repair = false) => {
    const openAPIConverter = new commons_server_1.OpenAPIConverter();
    const environments = [];
    let filePathIndex = 0;
    let errorMessage = `${cli_messages_constants_1.CLIMessages.DATA_INVALID}:`;
    for (const [index, filePath] of filePaths.entries()) {
        let environment = null;
        try {
            environment = await openAPIConverter.convertFromOpenAPI(filePath);
        }
        catch (openAPIError) {
            errorMessage += `\nOpenAPI parser: ${openAPIError.message}`;
            // immediately throw if the file is not a JSON file
            if (filePath.includes('.yml') || filePath.includes('.yaml')) {
                throw new Error(errorMessage);
            }
            try {
                let data;
                if (filePath.startsWith('http')) {
                    data = await (await fetch(filePath)).text();
                }
                else {
                    data = await fs_1.promises.readFile(filePath, { encoding: 'utf-8' });
                }
                if (typeof data === 'string') {
                    data = JSON.parse(data);
                }
                if (typeof data === 'object') {
                    environment = await migrateAndValidateEnvironment(data, repair);
                }
            }
            catch (JSONError) {
                errorMessage += `\nMockoon parser: ${JSONError.message}`;
                throw new Error(errorMessage);
            }
        }
        if (environment) {
            if (userOptions.ports[index] !== undefined) {
                environment.port = userOptions.ports[index];
            }
            if (userOptions.hostnames[index] !== undefined) {
                environment.hostname = userOptions.hostnames[index];
            }
            environments.push({ environment, originalPath: filePath });
        }
        filePathIndex++;
    }
    if (environments.length === 0) {
        throw new Error(cli_messages_constants_1.CLIMessages.ENVIRONMENT_NOT_AVAILABLE_ERROR);
    }
    return environments;
};
exports.parseDataFiles = parseDataFiles;
//# sourceMappingURL=data.js.map