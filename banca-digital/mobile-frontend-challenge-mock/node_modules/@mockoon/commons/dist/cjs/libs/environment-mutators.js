"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fullReorderEntitiesMutator = exports.removeCallbackMutator = exports.updateCallbackMutator = exports.addCallbackMutator = exports.removeRouteResponseMutator = exports.updateRouteResponseMutator = exports.addRouteResponseMutator = exports.removeDatabucketMutator = exports.updateDatabucketMutator = exports.addDatabucketMutator = exports.removeFolderMutator = exports.updateFolderMutator = exports.addFolderMutator = exports.reorderCallbackMutator = exports.reorderDatabucketMutator = exports.reorderRouteResponseMutator = exports.reorderRoutesMutator = exports.removeRouteMutator = exports.updateRouteMutator = exports.addRouteMutator = exports.updateEnvironmentMutator = void 0;
const reorder_model_1 = require("../models/reorder.model");
const route_model_1 = require("../models/route.model");
const mutator_utils_1 = require("../utils/mutator-utils");
/**
 * Update an environment direct properties
 *
 * @param environment
 * @param properties
 * @returns
 */
const updateEnvironmentMutator = (environment, properties) => (Object.assign(Object.assign({}, environment), properties));
exports.updateEnvironmentMutator = updateEnvironmentMutator;
/**
 * Add a route to an environment, and insert it in the root level or in a folder
 *
 * @param environment
 * @param newRoute
 * @param parentId
 * @returns
 */
const addRouteMutator = (environment, newRoute, parentId) => {
    let rootChildren = environment.rootChildren;
    const routes = [...environment.routes];
    let folders = environment.folders;
    routes.push(newRoute);
    // insert route in root level or folder
    if (parentId === 'root') {
        rootChildren = [
            ...environment.rootChildren,
            { type: 'route', uuid: newRoute.uuid }
        ];
    }
    else {
        folders = environment.folders.map((folder) => {
            if (folder.uuid === parentId) {
                return Object.assign(Object.assign({}, folder), { children: [...folder.children, { type: 'route', uuid: newRoute.uuid }] });
            }
            return folder;
        });
    }
    return Object.assign(Object.assign({}, environment), { routes,
        folders,
        rootChildren });
};
exports.addRouteMutator = addRouteMutator;
/**
 * Update a route direct properties in an environment
 *
 * @param environment
 * @param routeUuid
 * @param properties
 * @returns
 */
const updateRouteMutator = (environment, routeUuid, properties) => (Object.assign(Object.assign({}, environment), { routes: environment.routes.map((route) => {
        if (route.uuid === routeUuid) {
            return Object.assign(Object.assign({}, route), properties);
        }
        return route;
    }) }));
exports.updateRouteMutator = updateRouteMutator;
/**
 * Remove a route from an environment, and remove it from the root level or from a folder
 *
 * @param environment
 * @param routeUuid
 * @returns
 */
const removeRouteMutator = (environment, routeUuid) => {
    let newRootChildren = environment.rootChildren;
    let newFolders = environment.folders;
    const newRoutes = environment.routes.filter((route) => route.uuid !== routeUuid);
    // parent is root level
    if (environment.rootChildren.some((rootChild) => rootChild.uuid === routeUuid)) {
        // remove route from root level
        newRootChildren = [
            ...environment.rootChildren.filter((rootChild) => rootChild.uuid !== routeUuid)
        ];
    }
    else {
        newFolders = environment.folders.map((folder) => {
            if (folder.children.some((child) => child.uuid === routeUuid)) {
                return Object.assign(Object.assign({}, folder), { children: folder.children.filter((child) => child.uuid !== routeUuid) });
            }
            return folder;
        });
    }
    return Object.assign(Object.assign({}, environment), { routes: newRoutes, folders: newFolders, rootChildren: newRootChildren });
};
exports.removeRouteMutator = removeRouteMutator;
/**
 * Reorder a route in an environment
 *
 * @param environment
 * @param reorderAction
 * @returns
 */
const reorderRoutesMutator = (environment, reorderAction) => {
    let newRootChildren = environment.rootChildren;
    let newFolders = environment.folders;
    // check in which container the source item is. It could have been moved in another container in the meantime (sync)
    const containerId = (0, mutator_utils_1.findRouteOrFolderContainer)(reorderAction.sourceId, environment);
    // only do something if it can be found in the environment
    if (containerId) {
        // remove source item UUID from its parent container children
        if (containerId === 'root') {
            newRootChildren = newRootChildren.filter((rootChild) => rootChild.uuid !== reorderAction.sourceId);
        }
        else {
            newFolders = newFolders.map((folder) => {
                if (folder.uuid === containerId) {
                    return Object.assign(Object.assign({}, folder), { children: folder.children.filter((folderChild) => folderChild.uuid !== reorderAction.sourceId) });
                }
                return folder;
            });
        }
        // move in correct target (inside or before/after)
        if (reorderAction.reorderActionType === reorder_model_1.ReorderActionType.INSIDE) {
            if (reorderAction.isTargetContainer) {
                newFolders = newFolders.map((folder) => {
                    if (folder.uuid === reorderAction.targetId &&
                        // check that the target folder doesn't already contain the source item
                        !folder.children.find((folderChild) => folderChild.uuid === reorderAction.sourceId)) {
                        return Object.assign(Object.assign({}, folder), { children: [
                                ...folder.children,
                                {
                                    type: reorderAction.isSourceContainer ? 'folder' : 'route',
                                    uuid: reorderAction.sourceId
                                }
                            ] });
                    }
                    return folder;
                });
            }
            else if (reorderAction.targetId === 'root') {
                newRootChildren = [
                    ...newRootChildren,
                    {
                        type: reorderAction.isSourceContainer ? 'folder' : 'route',
                        uuid: reorderAction.sourceId
                    }
                ];
            }
        }
        else {
            if (reorderAction.targetParentId === 'root' &&
                // check that the target folder doesn't already contain the source item
                !newRootChildren.find((rootChild) => rootChild.uuid === reorderAction.sourceId)) {
                newRootChildren = (0, mutator_utils_1.insertItemAtTarget)(newRootChildren, reorderAction.reorderActionType, {
                    type: reorderAction.isSourceContainer ? 'folder' : 'route',
                    uuid: reorderAction.sourceId
                }, reorderAction.targetId);
            }
            else {
                newFolders = newFolders.map((folder) => {
                    if (folder.uuid === reorderAction.targetParentId &&
                        // check that the target folder doesn't already contain the source item
                        !folder.children.find((folderChild) => folderChild.uuid === reorderAction.sourceId)) {
                        return Object.assign(Object.assign({}, folder), { children: (0, mutator_utils_1.insertItemAtTarget)(folder.children, reorderAction.reorderActionType, {
                                type: reorderAction.isSourceContainer ? 'folder' : 'route',
                                uuid: reorderAction.sourceId
                            }, reorderAction.targetId) });
                    }
                    return folder;
                });
            }
        }
        return Object.assign(Object.assign({}, environment), { folders: newFolders, rootChildren: newRootChildren });
    }
    return environment;
};
exports.reorderRoutesMutator = reorderRoutesMutator;
/**
 * Reorder a route response in an environment
 *
 * @param environment
 * @param routeUuid
 * @param reorderAction
 * @returns
 */
const reorderRouteResponseMutator = (environment, routeUuid, reorderAction) => (Object.assign(Object.assign({}, environment), { routes: environment.routes.map((route) => {
        if (route.uuid === routeUuid) {
            return Object.assign(Object.assign({}, route), { responses: (0, mutator_utils_1.moveItemAtTarget)(route.responses, reorderAction.reorderActionType, reorderAction.sourceId, reorderAction.targetId) });
        }
        return route;
    }) }));
exports.reorderRouteResponseMutator = reorderRouteResponseMutator;
/**
 * Reorder a databucket in an environment
 *
 * @param environment
 * @param reorderAction
 * @returns
 */
const reorderDatabucketMutator = (environment, reorderAction) => (Object.assign(Object.assign({}, environment), { data: (0, mutator_utils_1.moveItemAtTarget)(environment.data, reorderAction.reorderActionType, reorderAction.sourceId, reorderAction.targetId) }));
exports.reorderDatabucketMutator = reorderDatabucketMutator;
/**
 *  Reorder a callback in an environment
 *
 * @param environment
 * @param reorderAction
 * @returns
 */
const reorderCallbackMutator = (environment, reorderAction) => (Object.assign(Object.assign({}, environment), { callbacks: (0, mutator_utils_1.moveItemAtTarget)(environment.callbacks, reorderAction.reorderActionType, reorderAction.sourceId, reorderAction.targetId) }));
exports.reorderCallbackMutator = reorderCallbackMutator;
/**
 * Add a folder to an environment, and insert it in the root level or in a folder
 *
 * @param environment
 * @param newFolder
 * @param parentId
 * @returns
 */
const addFolderMutator = (environment, newFolder, parentId) => {
    let rootChildren = environment.rootChildren;
    let folders = [...environment.folders];
    folders.push(newFolder);
    // add to folder or root level
    if (parentId === 'root') {
        rootChildren = [
            ...environment.rootChildren,
            { type: 'folder', uuid: newFolder.uuid }
        ];
    }
    else {
        folders = folders.map((folder) => {
            if (folder.uuid === parentId) {
                return Object.assign(Object.assign({}, folder), { children: [
                        ...folder.children,
                        { type: 'folder', uuid: newFolder.uuid }
                    ] });
            }
            return folder;
        });
    }
    return Object.assign(Object.assign({}, environment), { folders,
        rootChildren });
};
exports.addFolderMutator = addFolderMutator;
/**
 * Update a folder direct properties in an environment
 *
 * @param environment
 * @param folderUuid
 * @param properties
 * @returns
 */
const updateFolderMutator = (environment, folderUuid, properties) => (Object.assign(Object.assign({}, environment), { folders: environment.folders.map((folder) => {
        if (folder.uuid === folderUuid) {
            return Object.assign(Object.assign({}, folder), properties);
        }
        return folder;
    }) }));
exports.updateFolderMutator = updateFolderMutator;
/**
 * Remove a folder from an environment, and remove it from the root level or from a folder
 *
 * @param environment
 * @param folderUuid
 * @returns
 */
const removeFolderMutator = (environment, folderUuid) => {
    let newFolders = environment.folders;
    let newRootChildren = environment.rootChildren;
    // parent is root level
    if (environment.rootChildren.some((rootchild) => rootchild.uuid === folderUuid)) {
        // remove folder from root level
        newRootChildren = [
            ...environment.rootChildren.filter((rootChild) => rootChild.uuid !== folderUuid)
        ];
    }
    else {
        // find and remove from parent folder
        newFolders = environment.folders.map((folder) => {
            if (folder.children.some((child) => child.uuid === folderUuid)) {
                return Object.assign(Object.assign({}, folder), { children: [
                        ...folder.children.filter((child) => child.uuid !== folderUuid)
                    ] });
            }
            return folder;
        });
    }
    // remove folder from the list
    newFolders = newFolders.filter((newFolder) => newFolder.uuid !== folderUuid);
    return Object.assign(Object.assign({}, environment), { folders: newFolders, rootChildren: newRootChildren });
};
exports.removeFolderMutator = removeFolderMutator;
/**
 * Insert a databucket in an environment
 *
 * @param environment
 * @param newDataBucket
 * @param insertAfterUuid
 * @returns
 */
const addDatabucketMutator = (environment, newDatabucket, insertAfterUuid) => {
    const data = [...environment.data];
    let afterIndex = data.length;
    if (insertAfterUuid) {
        const targetIndex = environment.data.findIndex((databucket) => databucket.uuid === insertAfterUuid);
        if (targetIndex !== -1) {
            afterIndex = targetIndex + 1;
        }
    }
    data.splice(afterIndex, 0, newDatabucket);
    return Object.assign(Object.assign({}, environment), { data });
};
exports.addDatabucketMutator = addDatabucketMutator;
/**
 * Update a databucket direct properties in an environment
 * @param environment
 * @param databucketUuid
 * @param properties
 * @returns
 */
const updateDatabucketMutator = (environment, databucketUuid, properties) => (Object.assign(Object.assign({}, environment), { data: environment.data.map((databucket) => {
        if (databucket.uuid === databucketUuid) {
            return Object.assign(Object.assign({}, databucket), properties);
        }
        return databucket;
    }) }));
exports.updateDatabucketMutator = updateDatabucketMutator;
/**
 * Remove a databucket from an environment.
 * Remove the databucket id in all routes responses that use this databucket
 *
 * @param environment
 * @param databucketUuid
 */
const removeDatabucketMutator = (environment, databucketUuid) => {
    const deletedBucket = environment.data.find((databucket) => databucket.uuid === databucketUuid);
    return Object.assign(Object.assign({}, environment), { data: environment.data.filter((databucket) => databucket.uuid !== databucketUuid), routes: environment.routes.map((route) => {
            let needsUpdate = false;
            const newReponses = route.responses.map((response) => {
                if (response.databucketID === (deletedBucket === null || deletedBucket === void 0 ? void 0 : deletedBucket.id)) {
                    needsUpdate = true;
                    return Object.assign(Object.assign({}, response), { databucketID: '' });
                }
                return response;
            });
            if (needsUpdate) {
                return Object.assign(Object.assign({}, route), { responses: newReponses });
            }
            return route;
        }) });
};
exports.removeDatabucketMutator = removeDatabucketMutator;
/**
 * Add a route response to a route in an environment
 *
 * @param environment
 * @param routeUuid
 * @param newRouteResponse
 * @param insertAfterUuid
 * @returns
 */
const addRouteResponseMutator = (environment, routeUuid, newRouteResponse, insertAfterUuid) => (Object.assign(Object.assign({}, environment), { routes: environment.routes.map((route) => {
        if (route.uuid === routeUuid) {
            const responses = [...route.responses];
            let afterIndex = responses.length;
            if (insertAfterUuid) {
                const targetIndex = route.responses.findIndex((routeResponse) => routeResponse.uuid === insertAfterUuid);
                if (targetIndex !== -1) {
                    afterIndex = targetIndex + 1;
                }
            }
            responses.splice(afterIndex, 0, newRouteResponse);
            return Object.assign(Object.assign({}, route), { responses });
        }
        return route;
    }) }));
exports.addRouteResponseMutator = addRouteResponseMutator;
/**
 * Update a route response properties in an environment
 *
 * @param environment
 * @param routeUuid
 * @param routeResponseUuid
 * @param properties
 * @returns
 */
const updateRouteResponseMutator = (environment, routeUuid, routeResponseUuid, properties) => (Object.assign(Object.assign({}, environment), { routes: environment.routes.map((route) => {
        if (route.uuid === routeUuid) {
            return Object.assign(Object.assign({}, route), { responses: route.responses.map((response) => {
                    // if we set a route response as default, we need to remove the default flag from the previous default route response
                    if (properties.default &&
                        response.uuid !== routeResponseUuid &&
                        route.type !== route_model_1.RouteType.CRUD &&
                        response.default) {
                        return Object.assign(Object.assign({}, response), { default: false });
                    }
                    if (response.uuid === routeResponseUuid) {
                        return Object.assign(Object.assign({}, response), properties);
                    }
                    return response;
                }) });
        }
        return route;
    }) }));
exports.updateRouteResponseMutator = updateRouteResponseMutator;
/**
 * Remove a route response from a route in an environment
 *
 * @param environment
 * @param routeUuid
 * @param routeResponseUuid
 */
const removeRouteResponseMutator = (environment, routeUuid, routeResponseUuid) => (Object.assign(Object.assign({}, environment), { routes: environment.routes.map((route) => {
        if (route.uuid === routeUuid) {
            const deletedRouteResponse = route.responses.find((routeResponse) => routeResponse.uuid === routeResponseUuid);
            const newResponses = route.responses.filter((routeResponse) => routeResponse.uuid !== routeResponseUuid);
            if (newResponses.length > 0 && (deletedRouteResponse === null || deletedRouteResponse === void 0 ? void 0 : deletedRouteResponse.default)) {
                newResponses[0] = Object.assign(Object.assign({}, newResponses[0]), { default: true });
            }
            return Object.assign(Object.assign({}, route), { responses: newResponses });
        }
        return route;
    }) }));
exports.removeRouteResponseMutator = removeRouteResponseMutator;
/**
 * Add a callback to an environment
 *
 * @param environment
 * @param newCallback
 * @param insertAfterUuid
 */
const addCallbackMutator = (environment, newCallback, insertAfterUuid) => {
    const callbacks = [...environment.callbacks];
    let afterIndex = callbacks.length;
    if (insertAfterUuid) {
        const targetIndex = environment.callbacks.findIndex((callback) => callback.uuid === insertAfterUuid);
        if (targetIndex !== -1) {
            afterIndex = targetIndex + 1;
        }
    }
    callbacks.splice(afterIndex, 0, newCallback);
    return Object.assign(Object.assign({}, environment), { callbacks });
};
exports.addCallbackMutator = addCallbackMutator;
/**
 * Update a callback direct properties in an environment
 *
 * @param environment
 * @param callbackUuid
 * @param properties
 * @returns
 */
const updateCallbackMutator = (environment, callbackUuid, properties) => (Object.assign(Object.assign({}, environment), { callbacks: environment.callbacks.map((callback) => {
        if (callback.uuid === callbackUuid) {
            return Object.assign(Object.assign({}, callback), properties);
        }
        return callback;
    }) }));
exports.updateCallbackMutator = updateCallbackMutator;
/**
 * Remove a callback from an environment
 *
 * @param environment
 * @param callbackUuid
 * @returns
 */
const removeCallbackMutator = (environment, callbackUuid) => (Object.assign(Object.assign({}, environment), { callbacks: environment.callbacks.filter((callback) => callback.uuid !== callbackUuid), routes: environment.routes.map((route) => {
        let needsUpdate = false;
        const newReponses = route.responses.map((response) => {
            if (response.callbacks.length > 0) {
                const filteredCallbacks = response.callbacks.filter((callback) => callback.uuid !== callbackUuid);
                needsUpdate =
                    needsUpdate || filteredCallbacks.length !== response.callbacks.length;
                return Object.assign(Object.assign({}, response), { callbacks: filteredCallbacks });
            }
            return response;
        });
        if (needsUpdate) {
            return Object.assign(Object.assign({}, route), { responses: newReponses });
        }
        return route;
    }) }));
exports.removeCallbackMutator = removeCallbackMutator;
/**
 * Reorder all entities in an environment
 *
 * @param environment
 * @param entity - entity type to reorder
 * @param order - array of entities uuids
 * @param parentId - route uuid if entity is a route response, or 'root'/uuid of a folder if entity is a folder/route
 * @returns
 */
const fullReorderEntitiesMutator = (environment, entity, order, parentId) => {
    switch (entity) {
        case reorder_model_1.ReorderableContainers.ROUTES:
            if (parentId === 'root') {
                return Object.assign(Object.assign({}, environment), { rootChildren: (0, mutator_utils_1.sortByUuidsList)(environment.rootChildren, order) });
            }
            else {
                return Object.assign(Object.assign({}, environment), { folders: environment.folders.map((folder) => {
                        if (folder.uuid === parentId) {
                            return Object.assign(Object.assign({}, folder), { children: (0, mutator_utils_1.sortByUuidsList)(folder.children, order) });
                        }
                        return folder;
                    }) });
            }
        case reorder_model_1.ReorderableContainers.ROUTE_RESPONSES:
            return Object.assign(Object.assign({}, environment), { routes: environment.routes.map((route) => {
                    if (route.uuid === parentId) {
                        return Object.assign(Object.assign({}, route), { responses: (0, mutator_utils_1.sortByUuidsList)(route.responses, order) });
                    }
                    return route;
                }) });
        case reorder_model_1.ReorderableContainers.DATABUCKETS:
            return Object.assign(Object.assign({}, environment), { data: (0, mutator_utils_1.sortByUuidsList)(environment.data, order) });
        case reorder_model_1.ReorderableContainers.CALLBACKS:
            return Object.assign(Object.assign({}, environment), { callbacks: (0, mutator_utils_1.sortByUuidsList)(environment.callbacks, order) });
        default:
            return environment;
    }
};
exports.fullReorderEntitiesMutator = fullReorderEntitiesMutator;
//# sourceMappingURL=environment-mutators.js.map