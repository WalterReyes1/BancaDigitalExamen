"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildDemoEnvironment = exports.BuildEnvironment = exports.BuildCallback = exports.BuildDatabucket = exports.BuildCRUDRoute = exports.BuildHTTPRoute = exports.BuildFolder = exports.CloneCallback = exports.CloneDataBucket = exports.CloneRouteResponse = exports.BuildResponseCallback = exports.BuildResponseRule = exports.BuildRouteResponse = exports.BuildHeader = void 0;
const common_constants_1 = require("../constants/common.constants");
const environment_schema_constants_1 = require("../constants/environment-schema.constants");
const route_model_1 = require("../models/route.model");
const utils_1 = require("../utils/utils");
/**
 * Build a new environment or route response header
 */
const BuildHeader = (key = '', value = '') => ({ key, value });
exports.BuildHeader = BuildHeader;
/**
 * Build a new route response
 */
const BuildRouteResponse = () => (Object.assign({}, environment_schema_constants_1.RouteResponseDefault));
exports.BuildRouteResponse = BuildRouteResponse;
/**
 * Build a new response rule
 */
const BuildResponseRule = () => (Object.assign({}, environment_schema_constants_1.ResponseRuleDefault));
exports.BuildResponseRule = BuildResponseRule;
/**
 * Build a new callback request.
 */
const BuildResponseCallback = (defaultCallbackUuid) => (Object.assign(Object.assign({}, environment_schema_constants_1.ResponseCallbackDefault), { uuid: defaultCallbackUuid || '' }));
exports.BuildResponseCallback = BuildResponseCallback;
/**
 * Clone a new route response with a fresh UUID.
 * Make sure to reset default to false, as we can never have two default responses (also for CRUD the default is the one doing the CRUD operations).
 */
const CloneRouteResponse = (routeResponse) => (Object.assign(Object.assign({}, (0, utils_1.CloneObject)(routeResponse)), { uuid: (0, utils_1.generateUUID)(), label: `${routeResponse.label} (copy)`, default: false }));
exports.CloneRouteResponse = CloneRouteResponse;
/**
 * Clone a databucket with a renewd ids
 *
 * @param dataBucket
 * @returns
 */
const CloneDataBucket = (dataBucket) => (Object.assign(Object.assign({}, (0, utils_1.CloneObject)(dataBucket)), { uuid: (0, utils_1.generateUUID)(), id: (0, utils_1.GenerateUniqueID)(), name: `${dataBucket.name} (copy)` }));
exports.CloneDataBucket = CloneDataBucket;
/**
 * Clones a callback. We use the same strategy for id generation similar to data buckets.
 *
 * @param callback callback to clone
 * @returns cloned callback.
 */
const CloneCallback = (callback) => (Object.assign(Object.assign({}, (0, utils_1.CloneObject)(callback)), { uuid: (0, utils_1.generateUUID)(), id: (0, utils_1.GenerateUniqueID)(), name: `${callback.name} (copy)` }));
exports.CloneCallback = CloneCallback;
/**
 * Build a new folder object in the folder tree
 */
const BuildFolder = () => (Object.assign({}, environment_schema_constants_1.FolderDefault));
exports.BuildFolder = BuildFolder;
/**
 * Build a new HTTP route
 */
const BuildHTTPRoute = (hasDefaultRouteResponse = true, options = {
    endpoint: environment_schema_constants_1.RouteDefault.endpoint,
    body: environment_schema_constants_1.RouteResponseDefault.body
}) => {
    const defaultResponse = Object.assign(Object.assign({}, (0, exports.BuildRouteResponse)()), { default: true, body: options.body });
    return Object.assign(Object.assign({}, environment_schema_constants_1.RouteDefault), { type: route_model_1.RouteType.HTTP, method: route_model_1.Methods.get, endpoint: options.endpoint, responses: hasDefaultRouteResponse ? [defaultResponse] : [] });
};
exports.BuildHTTPRoute = BuildHTTPRoute;
/**
 * Build a new CRUD route
 */
const BuildCRUDRoute = (hasDefaultRouteResponse = true, options = {
    endpoint: environment_schema_constants_1.RouteDefault.endpoint,
    databucketID: environment_schema_constants_1.RouteResponseDefault.databucketID
}) => {
    // first CRUD route response is always the default one and cannot be deleted
    let defaultResponse = Object.assign(Object.assign({}, (0, exports.BuildRouteResponse)()), { default: true });
    defaultResponse = Object.assign(Object.assign({}, defaultResponse), { bodyType: route_model_1.BodyTypes.DATABUCKET, databucketID: options.databucketID });
    return Object.assign(Object.assign({}, environment_schema_constants_1.RouteDefault), { type: route_model_1.RouteType.CRUD, method: '', endpoint: options.endpoint, responses: hasDefaultRouteResponse ? [defaultResponse] : [] });
};
exports.BuildCRUDRoute = BuildCRUDRoute;
/**
 * Build a new databucket
 */
const BuildDatabucket = (dataBucket = {
    name: environment_schema_constants_1.DataBucketDefault.name,
    value: environment_schema_constants_1.DataBucketDefault.value
}) => (Object.assign(Object.assign({}, environment_schema_constants_1.DataBucketDefault), dataBucket));
exports.BuildDatabucket = BuildDatabucket;
/**
 * Build a new callback.
 */
const BuildCallback = () => (Object.assign({}, environment_schema_constants_1.CallbackDefault));
exports.BuildCallback = BuildCallback;
/**
 * Build a new environment
 */
const BuildEnvironment = (params = {
    hasDefaultRoute: true,
    hasDefaultHeader: true
}) => {
    const newRoute = (0, exports.BuildHTTPRoute)();
    return Object.assign(Object.assign({}, environment_schema_constants_1.EnvironmentDefault), { port: params.port !== undefined ? params.port : environment_schema_constants_1.EnvironmentDefault.port, routes: params.hasDefaultRoute ? [newRoute] : [], headers: params.hasDefaultHeader
            ? [(0, exports.BuildHeader)('Content-Type', 'application/json'), ...common_constants_1.CORSHeaders]
            : [], proxyReqHeaders: [(0, exports.BuildHeader)()], proxyResHeaders: [(0, exports.BuildHeader)()], rootChildren: params.hasDefaultRoute
            ? [{ type: 'route', uuid: newRoute.uuid }]
            : [] });
};
exports.BuildEnvironment = BuildEnvironment;
/**
 * Build a demo environment when starting the application for the first time
 */
const BuildDemoEnvironment = () => {
    const databucket = (0, exports.BuildDatabucket)();
    const newRoutes = [
        Object.assign({}, (0, exports.BuildCRUDRoute)()),
        (0, exports.BuildHTTPRoute)(), // templating
        (0, exports.BuildHTTPRoute)(), // rules
        (0, exports.BuildHTTPRoute)(), // route patterns
        (0, exports.BuildHTTPRoute)(), // guard
        (0, exports.BuildHTTPRoute)()
    ];
    return Object.assign(Object.assign({}, (0, exports.BuildEnvironment)()), { name: 'Demo API', data: [
            Object.assign(Object.assign({}, databucket), { name: 'Users', value: '[\n  {{#repeat 50}}\n  {\n    "id": "{{faker \'string.uuid\'}}",\n    "username": "{{faker \'internet.userName\'}}"\n  }\n  {{/repeat}}\n]' })
        ], routes: [
            Object.assign(Object.assign({}, newRoutes[0]), { endpoint: 'users', documentation: 'Endpoint performing CRUD operations on a data bucket (automatically creates GET, POST, PUT, DELETE routes)', responses: [
                    Object.assign(Object.assign({}, newRoutes[0].responses[0]), { databucketID: databucket.id, label: 'Perform CRUD operations on the "Users" databucket ("Data" tab at the top)' })
                ] }),
            Object.assign(Object.assign({}, newRoutes[1]), { method: route_model_1.Methods.get, endpoint: 'template', documentation: 'Generate random body (JSON, text, CSV, etc) with templating', responses: [
                    Object.assign(Object.assign({}, (0, exports.BuildRouteResponse)()), { label: "Creates 10 random users, or the amount specified in the 'total' query param", body: '{\n  "Templating example": "For more information about templating, click the blue \'i\' above this editor",\n  "users": [\n    {{# repeat (queryParam \'total\' \'10\') }}\n      {\n        "userId": "{{ faker \'number.int\' min=10000 max=100000 }}",\n        "firstname": "{{ faker \'person.firstName\' }}",\n        "lastname": "{{ faker \'person.lastName\' }}",\n        "friends": [\n          {{# repeat (faker \'number.int\' 5) }}\n            {\n              "id": "{{ faker \'string.uuid\' }}"\n            }\n          {{/ repeat }}\n        ]\n      },\n    {{/ repeat }}\n  ],\n  "total": "{{queryParam \'total\' \'10\'}}"\n}' })
                ] }),
            Object.assign(Object.assign({}, newRoutes[2]), { method: route_model_1.Methods.post, endpoint: 'content/:param1', documentation: 'Use multiple responses with rules', responses: [
                    Object.assign(Object.assign({}, (0, exports.BuildRouteResponse)()), { label: 'Default response', body: '{\n  "Rules example": "Default response. Served if route param \'param1\' is not present."\n}', default: true }),
                    Object.assign(Object.assign({}, (0, exports.BuildRouteResponse)()), { label: 'Content XYZ', body: "{\n  \"Rules example\": \"Content XYZ. Served if route param 'param1' equals 'xyz'. (See in 'Rules' tab)\"\n}", rules: [
                            {
                                target: 'params',
                                modifier: 'param1',
                                value: 'xyz',
                                invert: false,
                                operator: 'equals'
                            }
                        ] }),
                    Object.assign(Object.assign({}, (0, exports.BuildRouteResponse)()), { statusCode: 404, label: 'Content not found', body: "{\n  \"Rules example\": \"Content not found. Served if route param 'param1' is not equal to 'xyz'. (See in 'Rules' tab)\"\n}\n", rules: [
                            {
                                target: 'params',
                                modifier: 'param1',
                                value: '^(?!.*xyz).*$',
                                invert: false,
                                operator: 'regex'
                            }
                        ] })
                ] }),
            Object.assign(Object.assign({}, newRoutes[3]), { method: route_model_1.Methods.put, endpoint: 'path/with/pattern(s)?/*', documentation: 'Path supports various patterns', responses: [
                    Object.assign(Object.assign({}, (0, exports.BuildRouteResponse)()), { headers: [{ key: 'Content-Type', value: 'text/plain' }], body: "The current path will match the following routes: \nhttp://localhost:3000/path/with/pattern/\nhttp://localhost:3000/path/with/patterns/\nhttp://localhost:3000/path/with/patterns/anything-else\n\nLearn more about Mockoon's routing: https://mockoon.com/docs/latest/api-endpoints/routing/" })
                ] }),
            Object.assign(Object.assign({}, newRoutes[4]), { method: route_model_1.Methods.all, endpoint: 'protected/*', documentation: '"Guard" route protecting all routes starting with /protected/', responseMode: route_model_1.ResponseMode.FALLBACK, responses: [
                    Object.assign(Object.assign({}, (0, exports.BuildRouteResponse)()), { label: "Requires the presence of an 'Authorization' header", body: '{\n  "error": "Unauthorized"\n}', statusCode: 401, rules: [
                            {
                                target: 'header',
                                modifier: 'Authorization',
                                operator: 'null',
                                invert: false,
                                value: ''
                            }
                        ] })
                ] }),
            Object.assign(Object.assign({}, newRoutes[5]), { method: route_model_1.Methods.get, endpoint: 'protected/path', documentation: 'Protected route', responses: [
                    Object.assign(Object.assign({}, (0, exports.BuildRouteResponse)()), { headers: [{ key: 'Content-Type', value: 'text/plain' }], body: 'You can serve the same responses based on the same rules for all or part of your endpoints by creating global routes using the fallback mode and a wildcard path. \nThis is useful if you want to protect all your endpoints by checking if an Authorization header is present or if you want to verify that all your requests contain a specific property in their body.\nTo learn more: https://mockoon.com/docs/latest/route-responses/global-routes-with-rules/' })
                ] }),
            Object.assign(Object.assign({}, newRoutes[6]), { method: route_model_1.Methods.get, endpoint: 'forward-and-record', documentation: 'Can Mockoon forward or record entering requests?', responses: [
                    Object.assign(Object.assign({}, (0, exports.BuildRouteResponse)()), { headers: [{ key: 'Content-Type', value: 'text/plain' }], body: 'Mockoon can also act as a proxy and forward all entering requests that are not caught by declared routes. \nYou can activate this option in the environment settings ("Settings" tab at the top). \nTo learn more: https://mockoon.com/docs/latest/server-configuration/proxy-mode/\n\nAll entering requests, and responses from the proxied server will be recorded and can be automatically mocked ("Logs" tab at the top).\nTo learn more: https://mockoon.com/docs/latest/logging-and-recording/requests-logging/' })
                ] })
        ], rootChildren: newRoutes.map((route) => ({
            type: 'route',
            uuid: route.uuid
        })) });
};
exports.BuildDemoEnvironment = BuildDemoEnvironment;
//# sourceMappingURL=schema-builder.js.map