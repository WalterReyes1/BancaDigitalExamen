"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findRouteOrFolderContainer = exports.sortByUuidsList = exports.moveItemAtTarget = exports.insertItemAtTarget = exports.insertAtIndex = exports.removeAtIndex = void 0;
const reorder_model_1 = require("../models/reorder.model");
/**
 * Remove item from array by index
 *
 * @param items
 * @returns
 */
const removeAtIndex = (items, index) => items.splice(index, 1)[0];
exports.removeAtIndex = removeAtIndex;
/**
 * Insert item in array at index
 *
 * @param items
 * @param index
 * @param item
 * @returns
 *
 */
const insertAtIndex = (items, index, item) => {
    items.splice(index, 0, item);
    return items;
};
exports.insertAtIndex = insertAtIndex;
/**
 * Insert an item in an array before or after the target's index
 * Create a copy of the array.
 *
 * @param items
 * @param itemToInsert
 * @param actionType
 * @param targetUUID
 * @returns
 */
const insertItemAtTarget = (items, actionType, itemToInsert, targetUUID) => {
    const newItems = [...items];
    const targetIndex = newItems.findIndex((item) => item.uuid === targetUUID);
    newItems.splice(actionType === reorder_model_1.ReorderActionType.BEFORE ? targetIndex : targetIndex + 1, 0, itemToInsert);
    return newItems;
};
exports.insertItemAtTarget = insertItemAtTarget;
/**
 * Reorder a list of items (string or objects with UUID) by moving an item before or after a target
 * Create a copy of the array.
 *
 * @param items
 * @param actionType
 * @param sourceId - can be a string id or a UUID
 * @param targetId - can be a string id or a UUID
 * @returns
 */
const moveItemAtTarget = (items, actionType, sourceId, targetId) => {
    const newItems = [...items];
    const sourceIndex = newItems.findIndex((arrayItem) => (typeof arrayItem === 'string' ? arrayItem : arrayItem.uuid) === sourceId);
    const itemToMove = (0, exports.removeAtIndex)(newItems, sourceIndex);
    let targetIndex = newItems.findIndex((arrayitem) => (typeof arrayitem === 'string' ? arrayitem : arrayitem.uuid) === targetId);
    targetIndex =
        actionType === reorder_model_1.ReorderActionType.AFTER ? targetIndex + 1 : targetIndex;
    (0, exports.insertAtIndex)(newItems, targetIndex, itemToMove);
    return newItems;
};
exports.moveItemAtTarget = moveItemAtTarget;
/**
 * Sort a list of items by a list of UUIDs
 *
 * @param items
 * @param uuids
 * @returns
 */
const sortByUuidsList = (items, uuids) => {
    const newItems = [...items];
    newItems.sort((a, b) => {
        // ensure that items not in the list are at the end
        if (!uuids.includes(a.uuid)) {
            return 1;
        }
        return uuids.indexOf(a.uuid) - uuids.indexOf(b.uuid);
    });
    return newItems;
};
exports.sortByUuidsList = sortByUuidsList;
/**
 * Return the current container of a route or folder
 * if not found, return null
 *
 * @param routeOrFolderUuid
 * @param environment
 */
const findRouteOrFolderContainer = (routeOrFolderUuid, environment) => {
    const inRoot = environment.rootChildren.find((child) => child.uuid === routeOrFolderUuid);
    if (inRoot) {
        return 'root';
    }
    const container = environment.folders.find((folder) => folder.children.some((child) => child.uuid === routeOrFolderUuid));
    if (container) {
        return container.uuid;
    }
    return null;
};
exports.findRouteOrFolderContainer = findRouteOrFolderContainer;
//# sourceMappingURL=mutator-utils.js.map