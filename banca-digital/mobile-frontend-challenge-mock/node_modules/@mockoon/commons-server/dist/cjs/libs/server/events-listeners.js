"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listenServerEvents = void 0;
const commons_1 = require("@mockoon/commons");
const util_1 = require("util");
const server_messages_constants_1 = require("../../constants/server-messages.constants");
const authorizationHeaders = ['authorization', 'proxy-authorization'];
const filterAuthorizationHeaders = (header) => {
    if (authorizationHeaders.includes(header.key.toLowerCase())) {
        const headerSplit = header.value.split(' ');
        header.value = headerSplit.length === 1 ? '***' : `${headerSplit[0]} ***`;
    }
    return header;
};
const listenServerEvents = function (server, environment, logger, logTransaction) {
    const defaultLogMeta = {
        environmentName: environment.name,
        environmentUUID: environment.uuid,
        app: 'mockoon-server'
    };
    server.on('started', () => {
        logger.info((0, util_1.format)(server_messages_constants_1.ServerMessages.SERVER_STARTED, environment.port), Object.assign({}, defaultLogMeta));
        if (!!process.send) {
            process.send('ready');
        }
    });
    server.on('stopped', () => {
        logger.info(server_messages_constants_1.ServerMessages.SERVER_STOPPED, Object.assign({}, defaultLogMeta));
    });
    server.on('error', (errorCode, error, payload) => {
        const errorMeta = Object.assign({}, defaultLogMeta);
        let message = '';
        switch (errorCode) {
            case 'PORT_ALREADY_USED':
                message = (0, util_1.format)(server_messages_constants_1.ServerMessages[errorCode], environment.port);
                break;
            case 'PORT_INVALID':
                message = (0, util_1.format)(server_messages_constants_1.ServerMessages[errorCode], environment.port);
                break;
            case 'HOSTNAME_UNKNOWN':
                message = (0, util_1.format)(server_messages_constants_1.ServerMessages[errorCode], environment.hostname);
                break;
            case 'HOSTNAME_UNAVAILABLE':
                message = (0, util_1.format)(server_messages_constants_1.ServerMessages[errorCode], environment.hostname);
                break;
            case 'REQUEST_BODY_PARSE':
            case 'ROUTE_CREATION_ERROR':
            case 'ROUTE_CREATION_ERROR_REGEX':
            case 'ROUTE_SERVING_ERROR':
            case 'ROUTE_FILE_SERVING_ERROR':
            case 'UNKNOWN_SERVER_ERROR':
            case 'HEADER_PARSING_ERROR':
            case 'CALLBACK_ERROR':
            case 'CALLBACK_FILE_ERROR':
                message = (0, util_1.format)(server_messages_constants_1.ServerMessages[errorCode], (error === null || error === void 0 ? void 0 : error.message) || '');
                break;
            case 'CERT_FILE_NOT_FOUND':
                message = (0, util_1.format)(server_messages_constants_1.ServerMessages[errorCode]);
                break;
            case 'PROXY_ERROR':
                message = (0, util_1.format)(server_messages_constants_1.ServerMessages[errorCode], environment.proxyHost, error === null || error === void 0 ? void 0 : error.message);
                break;
            case 'ROUTE_NO_LONGER_EXISTS':
                message = server_messages_constants_1.ServerMessages[errorCode];
                break;
        }
        logger.error(message, Object.assign(Object.assign({}, errorMeta), payload));
    });
    server.on('creating-proxy', () => {
        logger.info((0, util_1.format)(server_messages_constants_1.ServerMessages.SERVER_CREATING_PROXY, environment.proxyHost), Object.assign({}, defaultLogMeta));
    });
    server.on('transaction-complete', (transaction) => {
        const logMeta = Object.assign(Object.assign({}, defaultLogMeta), { requestMethod: transaction.request.method.toUpperCase(), requestPath: transaction.request.urlPath, responseStatus: transaction.response.statusCode, requestProxied: transaction.proxied });
        if (logTransaction) {
            logMeta.transaction = (0, commons_1.CloneObject)(transaction);
            logMeta.transaction.request.headers =
                logMeta.transaction.request.headers.map(filterAuthorizationHeaders);
            logMeta.transaction.response.headers =
                logMeta.transaction.response.headers.map(filterAuthorizationHeaders);
            logMeta.transaction.request.method =
                logMeta.transaction.request.method.toUpperCase();
        }
        logger.info('Transaction recorded', logMeta);
    });
    server.on('callback-invoked', (callback) => {
        const logMeta = Object.assign(Object.assign({}, defaultLogMeta), { callbackName: callback.name, callbackMethod: callback.method, callbackUrl: callback.url, callbackStatus: callback.status });
        if (logTransaction) {
            const clonedCallback = (0, commons_1.CloneObject)(callback);
            logMeta.callback = clonedCallback;
            logMeta.callback.requestHeaders = logMeta.callback.requestHeaders.map(filterAuthorizationHeaders);
            logMeta.callback.responseHeaders = logMeta.callback.responseHeaders.map(filterAuthorizationHeaders);
        }
        logger.info('Callback invoked', logMeta);
    });
};
exports.listenServerEvents = listenServerEvents;
//# sourceMappingURL=events-listeners.js.map