"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getValueFromPath = exports.fullTextSearch = exports.preparePath = exports.dedupSlashes = exports.routesFromFolder = exports.convertPathToArray = exports.resolvePathFromEnvironment = exports.objectFromSafeString = exports.numberFromSafeString = exports.fromSafeString = exports.FromBase64 = exports.ToBase64 = exports.DecompressBody = exports.IsEmpty = void 0;
exports.isBodySupportingMethod = isBodySupportingMethod;
exports.CreateCallbackInvocation = CreateCallbackInvocation;
exports.CreateTransaction = CreateTransaction;
const commons_1 = require("@mockoon/commons");
const handlebars_1 = require("handlebars");
const jsonpath_plus_1 = require("jsonpath-plus");
const object_path_1 = require("object-path");
const path_1 = require("path");
const url_1 = require("url");
const zlib_1 = require("zlib");
/**
 * Transform http headers objects to Mockoon's Header key value object
 *
 * @param object
 */
const TransformHeaders = (headers) => Object.keys(headers).reduce((newHeaders, key) => {
    const headerValue = headers[key];
    let value = '';
    if (headerValue !== undefined) {
        if (Array.isArray(headerValue)) {
            value = headerValue.join(',');
        }
        else {
            value = headerValue.toString();
        }
    }
    newHeaders.push({ key, value });
    return newHeaders;
}, []);
/**
 * Sort by ascending order
 *
 * @param a
 * @param b
 */
const AscSort = (a, b) => {
    if (a.key < b.key) {
        return -1;
    }
    else {
        return 1;
    }
};
/**
 * Check if an Object or Array is empty
 *
 * @param obj
 */
const IsEmpty = (obj) => [Object, Array].includes((obj || {}).constructor) &&
    !Object.entries(obj || {}).length;
exports.IsEmpty = IsEmpty;
/**
 * Decompress body based on content-encoding
 *
 * @param response
 */
const DecompressBody = (response) => {
    if (!response.body) {
        return response.body;
    }
    const contentEncoding = response.getHeader('content-encoding');
    let body = response.body;
    switch (contentEncoding) {
        case 'gzip':
            body = (0, zlib_1.unzipSync)(body);
            break;
        case 'br':
            body = (0, zlib_1.brotliDecompressSync)(body);
            break;
        case 'deflate':
            body = (0, zlib_1.inflateSync)(body);
            break;
        default:
            break;
    }
    return body.toString('utf-8');
};
exports.DecompressBody = DecompressBody;
/**
 * Returns true if given HTTP method is a body supporting one. Otherwise false.
 * @param method
 */
function isBodySupportingMethod(method) {
    return [commons_1.Methods.put, commons_1.Methods.post, commons_1.Methods.patch].indexOf(method) >= 0;
}
/**
 * Creates a callback invocation record which has information
 * about the invoked details.
 * @param callback
 * @param url
 * @param requestBody
 * @param requestHeaders
 * @param fetchResponse
 * @param responseBody
 */
function CreateCallbackInvocation(callback, url, requestBody, requestHeaders, fetchResponse, responseBody) {
    const resHeadersObj = Object.fromEntries(fetchResponse.headers.entries());
    return {
        name: callback.name,
        url,
        method: callback.method,
        requestBody,
        requestHeaders,
        status: fetchResponse.status,
        responseBody,
        responseHeaders: Object.keys(resHeadersObj).map((k) => ({ key: k, value: resHeadersObj[k] }))
    };
}
/**
 * Create a Transaction object from express req/res.
 * To be used after the response closes
 *
 * @param request
 * @param response
 */
function CreateTransaction(request, response) {
    const requestUrl = new url_1.URL(request.originalUrl, 'http://localhost/');
    let queryString = requestUrl.search.slice(1);
    try {
        queryString = decodeURI(queryString);
    }
    catch (err) { }
    return {
        request: {
            method: request.method.toLowerCase(),
            urlPath: requestUrl.pathname,
            route: request.route ? request.route.path : null,
            params: request.params
                ? Object.keys(request.params).map((paramName) => ({
                    name: paramName,
                    value: request.params[paramName]
                }))
                : [],
            query: requestUrl ? queryString : null,
            queryParams: request.query,
            body: request.stringBody,
            headers: TransformHeaders(request.headers).sort(AscSort)
        },
        response: {
            statusCode: response.statusCode,
            statusMessage: response.statusMessage,
            headers: TransformHeaders(response.getHeaders()).sort(AscSort),
            body: (0, exports.DecompressBody)(response)
        },
        routeResponseUUID: response.routeResponseUUID,
        routeUUID: response.routeUUID,
        proxied: request.proxied || false,
        timestampMs: Date.now()
    };
}
/**
 * Convert a string to base64
 *
 * @param text
 */
const ToBase64 = (text) => Buffer.from(text, 'utf-8').toString('base64');
exports.ToBase64 = ToBase64;
/**
 * Convert base64 to a string
 *
 * @param base64
 */
const FromBase64 = (base64) => Buffer.from(base64, 'base64').toString('utf-8');
exports.FromBase64 = FromBase64;
/**
 * Convert a SafeString to a string if needed.
 *
 * @param text
 * @returns
 */
const fromSafeString = (text) => text instanceof handlebars_1.SafeString ? text.toString() : text;
exports.fromSafeString = fromSafeString;
/**
 * Parse a number from a SafeString if needed.
 *
 * @param text
 * @returns
 */
const numberFromSafeString = (text) => {
    const parsedText = text instanceof handlebars_1.SafeString ? text.toString() : text;
    return parseInt(parsedText, 10);
};
exports.numberFromSafeString = numberFromSafeString;
/**
 *
 * @param text
 * @returns object | null
 */
const objectFromSafeString = (text) => {
    const parsedText = text instanceof handlebars_1.SafeString ? text.toString() : text;
    // Remove any escape slashes used to escape double-quotes or single-quotes
    // (Check test case).
    // Surround all object keys with double-quotes to make it valid JSON text.
    const objectText = parsedText
        .replace(/\\/g, '')
        .replace(/(['"])?([a-zA-Z0-9_]+)(['"])?:/g, '"$2": ');
    try {
        return JSON.parse(objectText);
    }
    catch (e) {
        return null;
    }
};
exports.objectFromSafeString = objectFromSafeString;
/**
 * Resolve a file path relatively to the current environment folder if provided
 */
const resolvePathFromEnvironment = (filePath, environmentDirectory) => {
    if (environmentDirectory && !(0, path_1.isAbsolute)(filePath)) {
        return (0, path_1.resolve)(environmentDirectory, filePath);
    }
    return filePath;
};
exports.resolvePathFromEnvironment = resolvePathFromEnvironment;
/**
 * Convert an object path (for the object-path lib) containing escaped dots '\.'
 * to an array of strings to allow fetching properties containing dots.
 *
 * Example:
 * 'get.a.property\.with\.dots => ['get', 'a', 'property.with.dots']
 *
 * To query an object like this:
 *
 * ```
 * {
 *   get: {
 *     a: {
 *       'propery.with.dots': "value"
 *     }
 *   }
 * }
 * ```
 * @param str
 */
const convertPathToArray = (str) => {
    if (str.includes('\\.')) {
        return str
            .replace(/\\\./g, '%#%')
            .split('.')
            .map((s) => s.replace(/%#%/g, '.'));
    }
    return str;
};
exports.convertPathToArray = convertPathToArray;
/**
 * List routes in the order they appear in a folder children array (can be called recursively)
 *
 * If exclude is provided, it will exclude the routes with the provided UUIDs, or the routes in the provided folders by keyword in the folder name
 *
 * @param folderChildren
 * @param allFolders
 * @param allRoutes
 * @param exclude
 * @returns
 */
const routesFromFolder = (folderChildren, allFolders, allRoutes, exclude = []) => {
    const routesList = [];
    folderChildren.forEach((folderChild) => {
        if (folderChild.type === 'route') {
            const foundRoute = allRoutes.find((route) => route.uuid === folderChild.uuid &&
                !exclude.includes(route.uuid) &&
                !exclude.includes(route.endpoint));
            if (foundRoute) {
                routesList.push(foundRoute);
            }
        }
        else {
            const subFolder = allFolders.find((folder) => folder.uuid === folderChild.uuid && !exclude.includes(folder.name));
            if (subFolder) {
                routesList.push(...(0, exports.routesFromFolder)(subFolder.children, allFolders, allRoutes, exclude));
            }
        }
    });
    return routesList;
};
exports.routesFromFolder = routesFromFolder;
/**
 * Remove duplicate slashes from a string
 *
 * @param str
 * @returns
 */
const dedupSlashes = (str) => str.replace(/\/{2,}/g, '/');
exports.dedupSlashes = dedupSlashes;
/**
 * Prepare a path for express: add a leading slash, deduplicate slashes and replace spaces with %20
 *
 * @param endpointPrefix
 * @param endpoint
 * @returns
 */
const preparePath = (endpointPrefix, endpoint) => (0, exports.dedupSlashes)(`/${endpointPrefix}/${endpoint.replace(/ /g, '%20')}`);
exports.preparePath = preparePath;
/**
 * Perform a full text search on an object. The object can be any valid JSON type
 *
 * @param object
 * @param query
 * @returns
 */
const fullTextSearch = (object, query) => {
    if (typeof object === 'object' || typeof object === 'boolean') {
        return Object.values(object !== null && object !== void 0 ? object : []).some((value) => (0, exports.fullTextSearch)(value, query));
    }
    return new RegExp(query, 'i').test(String(object));
};
exports.fullTextSearch = fullTextSearch;
/**
 * Look for a value in an object or array using a path (dot notation or JSONPath).
 * If no path is provided, return the full data.
 * If the value is not found, return the default value.
 *
 * @param data
 * @param path
 * @param defaultValue
 * @returns
 */
const getValueFromPath = (data, path, defaultValue) => {
    if ((Array.isArray(data) || typeof data === 'object') &&
        typeof path === 'string' &&
        path !== '') {
        let foundValue;
        // Added wrap = false (Check https://github.com/mockoon/mockoon/issues/1297)
        if (path.startsWith('$')) {
            foundValue = (0, jsonpath_plus_1.JSONPath)({ json: data, path: path, wrap: false });
        }
        else {
            foundValue = (0, object_path_1.get)(data, (0, exports.convertPathToArray)(path));
        }
        return foundValue !== undefined ? foundValue : defaultValue;
    }
    return data;
};
exports.getValueFromPath = getValueFromPath;
//# sourceMappingURL=utils.js.map