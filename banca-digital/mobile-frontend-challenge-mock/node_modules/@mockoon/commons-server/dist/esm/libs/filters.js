import { get as objectGet } from 'object-path';
const isNum = (value) => !isNaN(parseFloat(value));
export const FILTERS = {
    eq: (data, query) => String(data) === query ||
        (isNum(data) && isNum(query) && Number(data) === Number(query)),
    ne: (data, query) => String(data) !== query &&
        (!isNum(data) || !isNum(query) || Number(data) !== Number(query)),
    gt: (data, query) => data > query,
    gte: (data, query) => data >= query,
    lt: (data, query) => data < query,
    lte: (data, query) => data <= query,
    like: (data, query) => new RegExp(query, 'i').test(String(data)),
    start: (data, query) => new RegExp(`^${query}`, 'i').test(String(data)),
    end: (data, query) => new RegExp(`${query}$`, 'i').test(String(data))
};
const FILTERS_REGEX = `^(.*)_(${Object.keys(FILTERS).join('|')})$`;
export function parseFilters(queryParams) {
    const result = [];
    for (const key in queryParams) {
        if (!queryParams.hasOwnProperty(key)) {
            continue;
        }
        const value = queryParams[key];
        const match = key.match(FILTERS_REGEX);
        if (match) {
            const [, path, filter] = match;
            result.push({ path, filter, value });
        }
    }
    return result;
}
export function applyFilter(data, filterData) {
    const { filter, path, value } = filterData;
    return FILTERS[filter](objectGet(data, path), value);
}
//# sourceMappingURL=filters.js.map